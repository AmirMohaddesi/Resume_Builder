# tasks.yaml
# Global rules (implicit for all tasks):
# - Call tools exactly as described; do NOT invent file paths.
# - write_json_file must receive a raw JSON string (no ``` fences).
# - Output is JSON only; no LaTeX or markdown.

# =========================
# PHASE 1: INPUT PROCESSING
# =========================

parse_job_description_task:
  description: >
    Input: {job_description} (raw text).
    Goal: Save output/parsed_jd.json with key JD fields.
    Extract:
      - title, company, location? (strings)
      - skills[], keywords[] (arrays)
      - cleaned_text (string)
      - optional: seniority ("Senior", "Staff"), focus_area ("Perception", etc.)
    On failure: set status="error" and a clear message.
    Use write_json_file("output/parsed_jd.json", json_str).
  expected_output: >
    JSON in output/parsed_jd.json:
    {status, message, title?, company?, location?, seniority?,
     focus_area?, skills[], keywords[], cleaned_text}.
  agent: jd_analyst

# =========================
# PHASE 2: SELECTION (LENGTH-AWARE)
# =========================

select_experiences_task:
  description: >
    Inputs:
      - profile_reader("output/user_profile.json")
      - read_json_file("output/parsed_jd.json")
    Goal: Choose a small, JD-aligned subset of experiences.
    Actions:
      - FIRST: Call design_error_checker(context="experience") to check for known design errors that users have reported.
      - Review the prevention guidance from design_error_checker and follow it carefully.
      - Length budget (for 1–2 pages):
        * Max 4 experiences.
        * Each: max 3–4 bullets, ~25 words per bullet.
      - Score all experiences vs JD title, focus_area, skills.
      - Pick top 3–4; assign priority (1=must keep, 2=nice to have).
      - Rewrite bullets to be concise, impact-focused, and not duplicates.
      - Save to output/selected_experiences.json.
  expected_output: >
    JSON in output/selected_experiences.json:
    {status, message, selected_experiences: [
      {id, title, company, location?, dates?, priority,
       bullets: [string, ...]}
    ]}.
  agent: experience_selector
  context:
    - parse_job_description_task

select_projects_task:
  description: >
    Inputs:
      - profile_reader("output/user_profile.json")
      - read_json_file("output/parsed_jd.json")
    Goal: Choose 2–3 JD-aligned projects with intelligently summarized bullet points.
    Actions:
      - FIRST: Call design_error_checker(context="projects") to check for known design errors that users have reported.
      - Review the prevention guidance from design_error_checker and follow it carefully.
      - Length budget (for 1–2 page resume):
        * Max 3 projects, each with 2–3 bullets.
        * Each bullet: max ~20–25 words, impact-focused.
      - Select 2–3 most relevant projects aligned with JD skills/keywords.
      - For each project, use project_summarizer tool to intelligently summarize bullet points:
        * Call project_summarizer with bullets and JD keywords from parsed_jd.json
        * Tool will condense long bullets, merge redundant points, and prioritize JD-relevant content
        * Use the summarized_bullets from tool output
      - Each bullet should be concise, action-oriented, and highlight impact.
      - Add priority (1=must keep, 2=nice to have).
      - Save to output/selected_projects.json.
  expected_output: >
    JSON in output/selected_projects.json:
    {status, message, selected_projects: [
      {name, role?, priority, url?, bullets: [string, ...]}
    ]}.
  agent: project_selector
  context:
    - parse_job_description_task

select_skills_task:
  description: >
    Inputs:
      - profile_reader("output/user_profile.json")
      - read_json_file("output/parsed_jd.json")
    Goal: Build a compact, JD-aligned skills list.
    Actions:
      - FIRST: Call design_error_checker(context="skills") to check for known design errors that users have reported.
      - Review the prevention guidance from design_error_checker and follow it carefully.
      - Length budget: 10–20 skills total.
      - Start from profile skills.
      - Emphasize overlap with JD skills/keywords.
      - De-duplicate and optionally group (Languages, Frameworks, Tools).
      - Save to output/selected_skills.json.
  expected_output: >
    JSON in output/selected_skills.json:
    {status, message,
     skills: [string, ...],
     groups?: {name: [skills]}}.
  agent: skill_selector
  context:
    - parse_job_description_task

# =========================
# PHASE 3: CORE CONTENT
# =========================

write_header_task:
  description: >
    Inputs:
      - profile_reader("output/user_profile.json")
      - read_json_file("output/selected_skills.json")
      - read_json_file("output/selected_experiences.json")
      - read_json_file("output/parsed_jd.json")
    Goal: Create header + target_title.
    Actions:
      - FIRST: Call design_error_checker(context="header") to check for known design errors that users have reported.
      - Review the prevention guidance from design_error_checker and follow it carefully.
      - Use only real contact info from profile (no invented data).
      - Extract from profile.identity: email, phone, location, website, linkedin, github.
      - location should be extracted from profile.identity.location if present.
      - target_title should reflect JD title/seniority (e.g., "Senior Software Engineer").
      - target_title is metadata only and will NOT be displayed in the PDF header.
      - Do NOT use pipe characters (|) in target_title - it should be a simple job title string.
      - CRITICAL: If creating a title_line for display, use AT MOST 2-3 pipe separators (|). Avoid excessive separators like "||||" which create visual clutter. Use pipes sparingly for visual clarity.
    Save to output/header.json.
  expected_output: >
    JSON in output/header.json:
    {status, message, name, location?, email, phone?,
     links?: [string], target_title}.
  agent: header_writer
  context:
    - select_skills_task
    - select_experiences_task
    - parse_job_description_task

write_summary_task:
  description: >
    Inputs:
      - read_json_file("output/selected_experiences.json")
      - read_json_file("output/selected_skills.json")
      - read_json_file("output/parsed_jd.json")
    Goal: Write a short JD-aligned summary from scratch.
    Actions:
      - FIRST: Call design_error_checker(context="summary") to check for known design errors that users have reported.
      - Review the prevention guidance from design_error_checker and follow it carefully.
      - Length budget: 2–3 sentences, ≤ ~90 words.
      - State years of experience + main area.
      - Highlight 2–3 strengths that match JD.
      - Include a few JD keywords naturally.
      - Do NOT call summary_editor tool - you are creating, not refining.
      - Save to output/summary.json.
  expected_output: >
    JSON in output/summary.json:
    {status, message, summary: string, approx_word_count: number}.
  agent: summary_creator
  context:
    - select_experiences_task
    - select_skills_task

write_education_section_task:
  description: >
    Input:
      - profile_reader("output/user_profile.json")
    Goal: Produce a compact education section.
    Actions:
      - FIRST: Call design_error_checker(context="education") to check for known design errors that users have reported.
      - Review the prevention guidance from design_error_checker and follow it carefully.
      - Length budget: Max 3 entries; each line-efficient.
      - Choose highest-value degrees (most recent / most relevant).
      - For each: degree, institution, location?, dates?, honors?.
      - Save to output/education.json.
  expected_output: >
    JSON in output/education.json:
    {status, message, education: [
      {degree, institution, location?, dates?, honors?}
    ]}.
  agent: education_writer

# =========================
# PHASE 4: QUALITY CHECKS
# =========================

ats_check_task:
  description: >
    Inputs:
      - profile_reader("output/user_profile.json")
      - read_json_file("output/parsed_jd.json")
      - read_json_file("output/selected_experiences.json")
      - read_json_file("output/selected_skills.json")
      - read_json_file("output/summary.json")
    Goal: Generate an ATS/readability report.
    Actions:
      - Score JD keyword coverage and skill match.
      - Identify issues and short, actionable suggestions.
      - Save to output/ats_report.json.
  expected_output: >
    JSON in output/ats_report.json:
    {status, message, keyword_coverage: number,
     match_score: number, issues: [string], suggestions: [string]}.
  agent: ats_checker
  context:
    - select_experiences_task
    - select_skills_task
    - write_summary_task

privacy_validation_task:
  description: >
    Inputs:
      - read_json_file("output/selected_experiences.json")
      - read_json_file("output/selected_projects.json")
      - read_json_file("output/summary.json")
      - profile_reader("output/user_profile.json")
    Goal: Flag privacy / sensitive-data issues and validate factuality.
    Actions:
      - Use content_validator tool with resume JSON data and profile JSON.
      - Tool checks for factuality, hallucinations, and privacy risks.
      - Also run privacy_guard_tool for additional scanning.
      - Summarize findings into output/privacy_report.json.
  expected_output: >
    JSON in output/privacy_report.json:
    {status, message, issues: [string], high_risk: [string], factuality_check: object}.
  agent: privacy_guard

# =========================
# PHASE 5: COVER LETTER
# =========================

write_cover_letter_task:
  description: >
    Inputs:
      - read_json_file("output/parsed_jd.json")
      - read_json_file("output/selected_experiences.json")
      - read_json_file("output/selected_skills.json")
      - read_json_file("output/selected_projects.json")
    Goal: Create a tailored cover letter JSON from scratch.
    Length budget:
      - 250–400 words, strictly ≤ 400.
    Actions:
      - Write 3–5 paragraphs (intro, 2–3 body, closing).
      - Focus on JD alignment using selected experiences/skills/projects.
      - Include key JD terms naturally.
      - Do NOT call cover_letter_editor tool - you are creating, not refining.
      - Save to output/cover_letter.json.
  expected_output: >
    JSON in output/cover_letter.json:
    {status, message, cover_letter_md: string,
     word_count: number, keywords_used: [string],
     skills_alignment: [string], red_flags: [string]}.
  agent: cover_letter_creator
  context:
    - parse_job_description_task
    - select_experiences_task
    - select_skills_task
    - select_projects_task

# =========================
# PHASE 6: REFINEMENT TASKS (LLM-Powered)
# =========================

refine_summary_task:
  description: >
    Inputs:
      - read_json_file("output/summary.json")
      - read_json_file("output/parsed_jd.json")
    Goal: Refine and shorten summary using LLM-powered summary_editor tool.
    Actions:
      - Read current summary from summary.json.
      - Extract JD keywords from parsed_jd.json.
      - Call summary_editor tool with summary text and JD keywords.
      - Tool will create crisp 1-2 sentence summary (≤90 words).
      - Use the refined_summary from tool output.
      - Save refined summary to output/summary_refined.json.
  expected_output: >
    JSON in output/summary_refined.json:
    {status, message, refined_summary: string, word_count: number, sentence_count: number}.
  agent: summary_refiner
  context:
    - write_summary_task

refine_cover_letter_task:
  description: >
    Inputs:
      - read_json_file("output/cover_letter.json")
      - read_json_file("output/parsed_jd.json")
    Goal: Refine and shorten cover letter using LLM-powered cover_letter_editor tool.
    Actions:
      - Read current cover letter from cover_letter.json.
      - Extract JD text from parsed_jd.json.
      - Call cover_letter_editor tool with cover_letter_md and JD text.
      - Tool will create polished cover letter (≤400 words) maintaining structure.
      - Use the refined_cover_letter from tool output.
      - Save refined cover letter to output/cover_letter_refined.json.
  expected_output: >
    JSON in output/cover_letter_refined.json:
    {status, message, refined_cover_letter: string, word_count: number}.
  agent: cover_letter_refiner
  context:
    - write_cover_letter_task

analyze_latex_errors_task:
  description: >
    Inputs:
      - read_latex_file("output/generated/rendered_resume.tex") (if available)
    Goal: Analyze LaTeX compilation errors and provide root cause + fixes.
    Actions:
      - This task runs ONLY if LaTeX compilation fails.
      - Read LaTeX compilation log (from latex_compile_pdf tool output or log file).
      - Call latex_error_analyzer tool with log text and optional LaTeX source.
      - Tool will identify root cause, error type, and recommend specific fixes.
      - Save analysis to output/latex_errors.json.
  expected_output: >
    JSON in output/latex_errors.json:
    {status, message, analysis: {root_cause: string, error_type: string, recommended_fix: string, code_example: string, missing_packages: [string]}}.
  agent: template_fixer
  context: []
  # Note: This task is conditionally executed only when LaTeX compilation fails

# =========================
# PHASE 7: OPTIONAL TEMPLATE FIXING
# =========================

fix_template_to_match_reference_task:
  description: >
    Optional debug task (not used in normal runs).
    Inputs:
      - Reference PDF path (from pipeline).
      - Current LaTeX template + compiled PDF.
    Goal: Suggest minimal LaTeX template edits to better match reference.
    Actions:
      - Compare PDFs (generated vs reference).
      - Locate spacing/header/section differences.
      - Adjust template via read_latex_file / write_latex_file.
      - Recompile with latex_compile_pdf.
      - Save to output/template_fix_report.json.
  expected_output: >
    JSON in output/template_fix_report.json:
    {status, message, changes: [string], template_path: string,
     iterations: number, final_match_score: number}.
  agent: template_fixer
  context: []

# =========================
# PHASE 8: ITERATIVE PAGE REDUCTION
# =========================

iterative_page_reduction_task:
  description: >
    CRITICAL: This task runs ONLY when resume exceeds 2-page limit after initial trimming.
    Goal: Iteratively remove least important content until resume fits in ≤2 pages.
    
    Process:
    1. Read current LaTeX file: read_latex_file("output/generated/rendered_resume.tex")
    2. Analyze LaTeX gaps: Call latex_gap_analyzer tool to detect excessive whitespace, gaps, and removable sections
    3. Rank content for removal: Call content_rank_analyzer tool to get prioritized removal suggestions
    4. Remove least important item: Use content_removal_tool to remove the top-priority item from removal_suggestions
    5. Re-estimate pages: Use length_budget estimation or check PDF page count
    6. Repeat steps 2-5 until pages ≤ 2.0 OR max 5 iterations reached
    
    Removal priority (from content_rank_analyzer):
    - Lowest priority experiences (priority_score < 60)
    - Least relevant projects
    - Least impactful bullets
    - Skills not in JD
    - Summary words (if still over)
    
    IMPORTANT:
    - Remove ONE item per iteration
    - Always remove the LOWEST priority item first
    - Stop when estimated_pages ≤ 2.0
    - Maximum 5 iterations to avoid infinite loops
    - Save removal log to output/page_reduction_log.json
    
  expected_output: >
    JSON in output/page_reduction_log.json:
    {status, message, iterations: number, items_removed: [{type, item, reason}],
     final_estimated_pages: number, target_met: boolean}.
  agent: pipeline_orchestrator
  context: []
  # Note: This task is conditionally executed only when resume exceeds 2 pages
