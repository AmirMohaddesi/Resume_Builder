# Simplified task configuration - Agents output JSON, Python handles LaTeX
# NO MORE LATEX IN AGENT TASKS!
#
# ARCHIVED TASKS: See tasks_archived.yaml for tasks replaced by deterministic Python functions
# or not currently wired into the runtime pipeline.

# ============================================
# PHASE 1: INPUT PROCESSING (1 task)
# ============================================

parse_job_description_task:
  description: >
    1. Parse job description: {job_description}
    2. Extract: title, company, location (optional), skills (array), keywords (array), cleaned_text (string)
    3. Write to output/parsed_jd.json using write_json_file
    
    Schema: {status: "success"|"error", message: string, title?: string, company?: string, location?: string, skills: array, keywords: array, cleaned_text: string}
    
    ⚠️ SAFETY RULES:
    - DO NOT invent fields - output EXACT schema only
    - DO NOT change field names - use exact names from schema
    - DO NOT wrap JSON in Markdown - pass raw JSON string to write_json_file
    - If extraction fails, set status="error" with message
  expected_output: >
    JSON with status, message, title, company, skills, keywords, cleaned_text (NO markdown, NO extra fields)
  agent: jd_analyst
  # IMPORTANT: Do NOT use output_file for this task.
  # The agent MUST write JSON using the write_json_file tool.

# ============================================
# PHASE 2: CONTENT SELECTION (3 focused tasks)
# ============================================

select_experiences_task:
  description: >
    1. Read profile_reader("output/user_profile.json")
    2. Read read_json_file("output/parsed_jd.json")
    3. Select top 3-5 experiences matching JD keywords
    4. Write to output/selected_experiences.json using write_json_file
    
    Schema: {status: "success", message: string, selected_experiences: [{organization: string, title: string, location?: string, dates: string, description: string}]}
    
    ⚠️ SAFETY RULES:
    - DO NOT invent fields - output EXACT schema only
    - DO NOT change field names - use exact names from schema
    - DO NOT wrap JSON in Markdown - pass raw JSON string to write_json_file
    - No reasoning. Strict JSON only. No markdown. No commentary.
  expected_output: >
    JSON with selected_experiences array (NO LaTeX, NO markdown)
  agent: experience_selector
  context:
    - parse_job_description_task
  # IMPORTANT: Do NOT use output_file for this task.

select_projects_task:
  description: >
    1. Read profile_reader("output/user_profile.json")
    2. Read read_json_file("output/parsed_jd.json")
    3. Select 2-4 projects matching JD keywords
    4. Write to output/selected_projects.json using write_json_file
    
    Schema: {status: "success", message: string, selected_projects: [{name: string, description: string, url?: string}]}
    
    ⚠️ SAFETY RULES:
    - DO NOT invent fields - output EXACT schema only
    - DO NOT change field names - use exact names from schema
    - DO NOT wrap JSON in Markdown - pass raw JSON string to write_json_file
    - No reasoning. Strict JSON only. No markdown. No commentary.
  expected_output: >
    JSON with selected_projects array (NO LaTeX, NO markdown)
  agent: project_selector
  context:
    - parse_job_description_task
  # IMPORTANT: Do NOT use output_file for this task.

select_skills_task:
  description: >
    1. Read profile_reader("output/user_profile.json")
    2. Read read_json_file("output/parsed_jd.json")
    3. Select 8-12 skills matching JD keywords
    4. Write to output/selected_skills.json using write_json_file
    
    Schema: {status: "success", message: string, selected_skills: [string, ...]}
    
    ⚠️ SAFETY RULES:
    - DO NOT invent fields - output EXACT schema only
    - DO NOT change field names - use exact names from schema
    - DO NOT wrap JSON in Markdown - pass raw JSON string to write_json_file
    - No reasoning. Strict JSON only. No markdown. No commentary.
  expected_output: >
    JSON with selected_skills array (NO LaTeX, NO markdown)
  agent: skill_selector
  context:
    - parse_job_description_task
  # IMPORTANT: Do NOT use output_file for this task.

# ============================================
# PHASE 3: CONTENT WRITING (3 focused tasks)
# ============================================

write_header_task:
  description: >
    1. Read read_json_file("output/parsed_jd.json") for keywords
    2. Read read_json_file("output/selected_skills.json")
    3. Read profile_reader("output/user_profile.json") for contact info
    4. Extract contact: phone, email, location, website, linkedin (username only), github (username only), google_scholar (full URL)
    5. Generate title_line: 3-5 JD keywords separated by | (e.g., "AI/ML Engineer | Robotics | PyTorch")
    6. Write to output/header_block.json using write_json_file
    
    Schema: {status: "success", message: string, title_line: string, contact_info: {phone?: string, email?: string, location?: string, website?: string, linkedin?: string, github?: string, google_scholar?: string}}
    
    ⚠️ SAFETY RULES:
    - DO NOT invent fields - output EXACT schema only
    - DO NOT change field names - use exact names from schema
    - DO NOT wrap JSON in Markdown - pass raw JSON string to write_json_file
    - DO NOT invent contact information - only use what exists in profile
  expected_output: >
    JSON with title_line and contact_info (NO markdown, NO extra fields)
  agent: header_writer
  context:
    - select_skills_task
    - select_experiences_task
    - parse_job_description_task
  # IMPORTANT: Do NOT use output_file for this task.

write_summary_task:
  description: >
    1. Read read_json_file("output/selected_experiences.json")
    2. Read read_json_file("output/selected_skills.json")
    3. Read read_json_file("output/parsed_jd.json") for context
    4. Write 2-3 sentence summary:
       - Sentence 1: Years of experience + primary expertise
       - Sentence 2: Key achievements/impact from experiences
       - Sentence 3 (optional): Relevant skills/specialization
    5. Use active voice, quantify achievements. Plain text only - NO LaTeX, NO markdown
    6. Write to output/summary_block.json using write_json_file
    
    Schema: {status: "success", message: string, summary: string}
    
    ⚠️ SAFETY RULES:
    - DO NOT invent fields - output EXACT schema only
    - DO NOT change field names - use exact names from schema
    - DO NOT wrap JSON in Markdown - pass raw JSON string to write_json_file
    - DO NOT invent achievements - only use selected_experiences.json data
  expected_output: >
    JSON with summary string (NO LaTeX, NO markdown, NO extra fields)
  agent: summary_writer
  context:
    - select_experiences_task
    - select_skills_task
  # IMPORTANT: Do NOT use output_file for this task.

write_education_section_task:
  description: >
    1. Read profile_reader("output/user_profile.json")
    2. Extract identity.education array
    3. For each entry: degree, institution, location (optional), dates, gpa (optional), honors (optional)
    4. Write to output/education_block.json using write_json_file
    5. If education array empty/missing, return education: []
    
    Schema: {status: "success", message: string, education: [{degree: string, institution: string, location?: string, dates: string, gpa?: string, honors?: string}]}
    
    ⚠️ SAFETY RULES:
    - DO NOT invent fields - output EXACT schema only
    - DO NOT change field names - use exact names from schema
    - DO NOT wrap JSON in Markdown - pass raw JSON string to write_json_file
  expected_output: >
    JSON with education array (NO LaTeX, NO markdown, NO extra fields)
  agent: education_writer
  # IMPORTANT: Do NOT use output_file for this task.

# ============================================
# PHASE 4: QUALITY & COVER LETTER (3 tasks)
# ============================================

ats_check_task:
  description: >
    1. Read read_json_file("output/parsed_jd.json") - if missing: set status="degraded", error_type="missing_jd"
    2. Read read_json_file("output/selected_experiences.json")
    3. Read read_json_file("output/selected_skills.json")
    4. Analyze keyword coverage:
       - present_keywords: JD keywords found in resume
       - missing_keywords: JD keywords not found
       - coverage_score: present/total (0.0-1.0)
       - recommendations: array of improvement suggestions
    5. Write to output/ats_report.json using write_json_file
    
    Schema: {status: "success"|"degraded"|"error", message: string, coverage_score: number, present_keywords: array, missing_keywords: array, recommendations: array, error_type?: string, hint?: string}
    
    ⚠️ SAFETY RULES:
    - DO NOT invent fields - output EXACT schema only
    - DO NOT change field names - use exact names from schema
    - DO NOT wrap JSON in Markdown - pass raw JSON string to write_json_file
  expected_output: >
    ATS report JSON with status, coverage_score, keywords, recommendations (NO markdown, NO extra fields)
  agent: ats_checker
  context:
    - select_experiences_task
    - select_skills_task
    - write_summary_task
  # IMPORTANT: Do NOT use output_file for this task.

privacy_validation_task:
  description: >
    1. Call privacy_guard_tool(content_path="output/user_profile.json", profile_path="output/user_profile.json", content_type="json", job_description="{job_description}")
    2. Check for: SSN, passport numbers, private addresses, credit card numbers
    3. Report: validation_status ("passed"|"failed"|"warning"), issues array
    4. Write to output/privacy_validation_report.json using write_json_file
    
    Schema: {status: "success"|"error", message: string, validation_status: "passed"|"failed"|"warning", issues: array, error_type?: string, hint?: string}
    
    ⚠️ SAFETY RULES:
    - DO NOT invent fields - output EXACT schema only
    - DO NOT change field names - use exact names from schema
    - DO NOT wrap JSON in Markdown - pass raw JSON string to write_json_file
  expected_output: >
    Privacy validation report JSON with status, validation_status, issues (NO markdown, NO extra fields)
  agent: privacy_guard
  # IMPORTANT: Do NOT use output_file for this task.

write_cover_letter_task:
  description: >
    1. Read read_json_file("output/user_profile.json")
    2. Read read_json_file("output/parsed_jd.json")
    3. Read read_json_file("output/selected_experiences.json")
    4. Read read_json_file("output/selected_skills.json")
    5. Read read_json_file("output/selected_projects.json")
    6. Generate cover letter (≤400 words):
       - Opening (2-3 sentences): Interest, role mention, 1-2 key qualifications
       - Body (2-3 paragraphs): Match 2-3 experiences/projects to JD, use examples
       - Closing (1-2 sentences): Reiterate interest, call to action
    7. Use JD keywords naturally
    8. NEVER invent information - only use user_profile.json data
    9. If JD missing: set red_flags=["missing_jd"], produce generic truthful letter
    10. Write to output/cover_letter.json using write_json_file
    
    Schema: {ok: boolean, status: "success"|"error", message: string, cover_letter_md: string, keywords_used: array, skills_alignment: array, red_flags: array, meta: {word_count: number, jd_available: boolean}, error_type: string|null, hint: string|null}
    
    ⚠️ SAFETY RULES:
    - DO NOT invent fields - output EXACT schema only
    - DO NOT change field names - use exact names from schema
    - DO NOT wrap JSON in Markdown - pass raw JSON string to write_json_file
    - Field MUST be "cover_letter_md" (not "cover_letter")
  expected_output: >
    Cover letter JSON with ok, status, cover_letter_md, keywords, alignment, red_flags, meta (NO markdown, NO extra fields)
  agent: coverletter_generator
  context:
    - parse_job_description_task
    - select_experiences_task
    - select_skills_task
    - select_projects_task
  # IMPORTANT: Do NOT use output_file for this task.

# ============================================
# PHASE 5: TEMPLATE MATCHING (optional task)
# ============================================

fix_template_to_match_reference_task:
  description: >
    Compare reference PDF with generated PDF, fix LaTeX template to match visually while preserving data-driven design.
    
    Template Variables: {reference_pdf_path}, {generated_pdf_path}, {template_tex_path}
    
    CRITICAL SAFETY RULES:
    - NEVER hard-code personal data - use macros only (\name{}, \email{}, etc.)
    - NEVER remove entire sections - only modify layout/formatting
    - ALWAYS preserve data-driven macros and % === AUTO:... === markers
    - PREFER commenting out code instead of deleting
    - KEEP macros consistent - update all usages if signature changes
    
    Steps:
    1. Compare PDFs: pdf_comparison_tool({reference_pdf_path}, {generated_pdf_path})
    2. Analyze LaTeX: latex_structure_analyzer({template_tex_path})
    3. Identify mismatches: header layout, contact formatting, section spacing, stray template text
    4. Edit template:
       - read_latex_file({template_tex_path})
       - Comment out extra template junk (don't delete)
       - Fix header structure, link rendering, section spacing
       - Keep all data fields driven by macros/JSON
       - Mark regions: % === AUTO:HEADER_START === ... % === AUTO:HEADER_END ===
       - write_latex_file to save
    5. Recompile: latex_compile_pdf
    6. Iterate if mismatch persists
    
    Write to output/template_fix_report.json using write_json_file.
    Schema: {status: "success"|"error", message: string, changes_made: array, template_path: string, iterations: number, final_match_score: number}
    
    ⚠️ SAFETY RULES:
    - DO NOT invent fields - output EXACT schema only
    - DO NOT change field names - use exact names from schema
    - DO NOT wrap JSON in Markdown - pass raw JSON string to write_json_file
  expected_output: >
    Template fix report JSON with changes_made, template_path, iterations, final_match_score (NO markdown, NO extra fields)
  agent: template_fixer
  context: []
  # IMPORTANT: Do NOT use output_file for this task.

